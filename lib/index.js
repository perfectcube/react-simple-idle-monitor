"use strict";function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj}}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj}}return _typeof(obj)}Object.defineProperty(exports,"__esModule",{value:true});exports.useIdleMonitor=useIdleMonitor;exports.default=exports.IdleMonitorContext=void 0;var _react=_interopRequireWildcard(require("react"));var _propTypes=_interopRequireDefault(require("prop-types"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _getRequireWildcardCache(){if(typeof WeakMap!=="function")return null;var cache=new WeakMap;_getRequireWildcardCache=function _getRequireWildcardCache(){return cache};return cache}function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}if(obj===null||_typeof(obj)!=="object"&&typeof obj!=="function"){return{default:obj}}var cache=_getRequireWildcardCache();if(cache&&cache.has(obj)){return cache.get(obj)}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}newObj.default=obj;if(cache){cache.set(obj,newObj)}return newObj}function _extends(){_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key]}}}return target};return _extends.apply(this,arguments)}function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_unsupportedIterableToArray(arr,i)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o==="string")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(n);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen)}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i]}return arr2}function _iterableToArrayLimit(arr,i){if(typeof Symbol==="undefined"||!(Symbol.iterator in Object(arr)))return;var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break}}catch(err){_d=true;_e=err}finally{try{if(!_n&&_i["return"]!=null)_i["return"]()}finally{if(_d)throw _e}}return _arr}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr}function _objectWithoutProperties(source,excluded){if(source==null)return{};var target=_objectWithoutPropertiesLoose(source,excluded);var key,i;if(Object.getOwnPropertySymbols){var sourceSymbolKeys=Object.getOwnPropertySymbols(source);for(i=0;i<sourceSymbolKeys.length;i++){key=sourceSymbolKeys[i];if(excluded.indexOf(key)>=0)continue;if(!Object.prototype.propertyIsEnumerable.call(source,key))continue;target[key]=source[key]}}return target}function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return{};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key]}return target}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable});keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key])})}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source))}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}}return target}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}// The following is a placeholder to keep TypeScript happy
// while the context is still to be created
/* istanbul ignore next */var notReady=function notReady(){throw new Error("Idle Monitor not active yet")};var initialContextStatusValues={isIdle:false,isRunning:false,timeout:0,startTime:0,className:"",_clientX:0,_clientY:0,_setTimer:0,_defaultTimeout:0,_currentTimeout:0,_activeClassName:"",_idleClassName:""};var initialContextValues=_objectSpread({},initialContextStatusValues,{activate:notReady,idle:notReady,run:notReady,stop:notReady});var Action;(function(Action){Action["Init"]="Init";Action["Run"]="Run";Action["Stop"]="Stop";Action["Idle"]="Idle";Action["Active"]="Active";Action["Event"]="Event";Action["SetTimeout"]="SetTimeout"})(Action||(Action={}));var IdleMonitorContext=(0,_react.createContext)(initialContextValues);exports.IdleMonitorContext=IdleMonitorContext;function reducer(state,action){switch(action.type){case Action.Run:{var t=action.timeout||state._defaultTimeout;return _objectSpread({},state,{isIdle:false,isRunning:true,startTime:Date.now(),timeout:t,className:state._activeClassName,_setTimer:t,_currentTimeout:t})}case Action.Stop:return _objectSpread({},state,{isIdle:false,isRunning:false,className:state._activeClassName,_setTimer:0});case Action.Idle:if(!state.isRunning)return state;return _objectSpread({},state,{isIdle:true,className:state._idleClassName,_setTimer:0});case Action.Active:{if(!state.isRunning)return state;var _t=action.timeout||state._currentTimeout;return _objectSpread({},state,{isIdle:false,startTime:Date.now(),timeout:_t,className:state._activeClassName,_setTimer:_t})}case Action.Event:{if(!state.isRunning||!state.isIdle)return state;var clientX=state._clientX;var clientY=state._clientY;if(action.ev.type==="mousemove"||action.ev.type==="touchmove"){var ev=action.ev;clientX=ev.clientX;clientY=ev.clientY;// Ignore small mouse movements possibly due to some odd vibration or shaking
if(Math.abs(state._clientX-clientX)+Math.abs(state._clientY-clientY)<20)return state}return _objectSpread({},state,{_clientX:clientX,_clientY:clientY,isIdle:false,startTime:Date.now(),timeout:state._currentTimeout,className:state._activeClassName,_setTimer:state._currentTimeout})}case Action.SetTimeout:{var _t2=action.timeout;return _objectSpread({},state,{_currentTimeout:_t2,_defaultTimeout:_t2,_setTimer:_t2})}// Should never be called, but Typescript expects a return so ...
/* istanbul ignore next */default:return state;}}// const logReducer = (
//   state: Readonly<IdleMonitorContextStatus & InternalState>,
//   action: Readonly<IdleMonitorActions>
// ): Readonly<IdleMonitorContextStatus & InternalState> => {
//   console.log('----- action', action);
//   console.log('----- before', state);
//   const newState = reducer(state, action);
//   console.log('----- after', newState);
//   return newState;
// };
var IdleMonitor=function IdleMonitor(_ref){var _ref$timeout=_ref.timeout,timeout=_ref$timeout===void 0?1000*60*20:_ref$timeout,_ref$events=_ref.events,events=_ref$events===void 0?["onMouseMove","onKeyDown","onWheel","onMouseDown","onTouchMove","onTouchStart"]:_ref$events,children=_ref.children,_ref$disabled=_ref.disabled,disabled=_ref$disabled===void 0?false:_ref$disabled,_ref$activeClassName=_ref.activeClassName,activeClassName=_ref$activeClassName===void 0?"":_ref$activeClassName,_ref$idleClassName=_ref.idleClassName,idleClassName=_ref$idleClassName===void 0?"":_ref$idleClassName,_ref$className=_ref.className,className=_ref$className===void 0?"":_ref$className,props=_objectWithoutProperties(_ref,["timeout","events","children","disabled","activeClassName","idleClassName","className"]);var _useReducer=(0,_react.useReducer)(reducer,_objectSpread({},initialContextStatusValues,{_activeClassName:activeClassName,className:activeClassName,_idleClassName:idleClassName,_defaultTimeout:timeout})),_useReducer2=_slicedToArray(_useReducer,2),state=_useReducer2[0],dispatch=_useReducer2[1];/* istanbul ignore else */if(process.env.NODE_ENV!=="production"){var invalidProps=Object.keys(props).filter(function(name){return events.indexOf(name)!==-1});if(invalidProps.length){throw new Error("Cannot attach event handlers to [".concat(invalidProps.join(", "),"] because they are already monitored by IdleMonitor"))}if(_react.default.Children.count(children)===0){throw new Error("IdleMonitor must enclose children")}if(!Array.isArray(events)||events.length===0){throw new Error("A list of UI events to be monitored for activity must be supplied")}if(events.some(function(name){return!/^on[A-Z]\w+/.test(name)})){throw new Error("Events names must be in React Synthetic events format")}}var isMounted=(0,_react.useRef)(false);var run=(0,_react.useCallback)(function(timeout){dispatch({type:Action.Run,timeout:timeout})},[dispatch]);var stop=(0,_react.useCallback)(function(){dispatch({type:Action.Stop})},[dispatch]);var idle=(0,_react.useCallback)(function(){dispatch({type:Action.Idle})},[dispatch]);var activate=(0,_react.useCallback)(function(timeout){dispatch({type:Action.Active,timeout:timeout})},[dispatch]);var onEventHandler=(0,_react.useCallback)(function(ev){ev.persist();dispatch({type:Action.Event,ev:ev})},[dispatch]);(0,_react.useEffect)(function(){if(!isMounted.current)return;if(disabled){stop()}else run()},[disabled,run,stop]);(0,_react.useEffect)(function(){if(!isMounted.current)return;dispatch({type:Action.SetTimeout,timeout:timeout})},[timeout]);var timerId=(0,_react.useRef)(0);(0,_react.useEffect)(function(){if(!isMounted.current)return;if(state._setTimer){timerId.current=setTimeout(idle,state._setTimer);return function(){clearTimeout(timerId.current)}}},[state._setTimer,idle]);(0,_react.useEffect)(function(){if(disabled){stop()}else{run()}isMounted.current=true;return function(){isMounted.current=false;stop()};// This one is for initialization and teardown only
/* eslint-disable-next-line react-hooks/exhaustive-deps */},[]);var listenTo=(0,_react.useMemo)(function(){return events.reduce(function(list,eventName){return _objectSpread({},list,_defineProperty({},eventName,onEventHandler))},{})},[events,onEventHandler]);var context=(0,_react.useMemo)(function(){var isIdle=state.isIdle,isRunning=state.isRunning,timeout=state.timeout,startTime=state.startTime,className=state.className;return{isIdle:isIdle,isRunning:isRunning,timeout:timeout,startTime:startTime,className:className,run:run,stop:stop,activate:activate,idle:idle};// I only want to depend on a few properties of state,
// not on the whole of it
/* eslint-disable-next-line react-hooks/exhaustive-deps */},[state.isIdle,state.isRunning,state.timeout,state.startTime,run,stop,activate,idle]);return/*#__PURE__*/_react.default.createElement(IdleMonitorContext.Provider,{value:context},/*#__PURE__*/_react.default.createElement("div",_extends({className:"".concat(state.className," ").concat(className).trim()||undefined},props,listenTo),children))};var _default=IdleMonitor;exports.default=_default;function useIdleMonitor(){return(0,_react.useContext)(IdleMonitorContext)}IdleMonitor.propTypes={timeout:_propTypes.default.number,events:_propTypes.default.arrayOf(_propTypes.default.string),children:_propTypes.default.node.isRequired,disabled:_propTypes.default.bool,activeClassName:_propTypes.default.string,idleClassName:_propTypes.default.string,className:_propTypes.default.string};